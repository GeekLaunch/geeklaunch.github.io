<!DOCTYPE html>
<html><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <title>How to speed up your code 224,444,739% using graphs - GeekLaunch</title>

    
    
    <meta name="description" content="(This article got a shout-out in Matt Parker&rsquo;s follow-up video. Did you know I also make YouTube videos?)
Matt Parker of Stand Up Maths recently uploaded a video entitled &ldquo;Can you find: five five-letter words with twenty-five unique letters?,&rdquo; which I highly recommend you watch to understand the point of this post, the problem we&rsquo;re trying to solve, and the algorithm we&rsquo;ll be optimizing.
In the video, he mentions that the Python code he wrote to solve the &ldquo;five five-letter words with twenty-five unique letters&rdquo; problem (or the &ldquo;5-5-25&rdquo; problem, for short) took 2,760,670." />
    <meta name="author" content="" />
    

    <link href="https://unpkg.com/@master/normal.css" rel="stylesheet">
    <script src="https://unpkg.com/@master/css"></script>
    <script src="https://unpkg.com/themes.js"></script>
    <script>window.themes = new window.Themes()</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DMBPKLBF8X"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-DMBPKLBF8X', { 'anonymize_ip': false });
}
</script>

<style>
  @keyframes highlight {
    0% {
      background-color: rgba(226, 230, 30, 0.4);
      outline: 0.2rem solid rgba(226, 230, 30, 0.4);
    }

    100% {
      background-color: unset;
      outline: 0.2rem solid transparent;
    }
  }

  :target {
    animation: highlight 1.2s forwards;
  }

</style>
<script>
  (() => {
    const scrollToId = id => {
      const el = document.getElementById(id);
      const mainNav = document.getElementById('mainNav');
      const offset = mainNav ? mainNav.clientHeight : 100;

      if (el) {
        const scrollToPosition = el.offsetTop - offset;
        window.scrollTo({
          top: scrollToPosition,
        });
      }
    };


    window.addEventListener('hashchange', e => {
      const id = new URL(e.newURL).hash.slice(1);
      scrollToId(id);
    });

    window.addEventListener('beforeunload', e => {
      console.log('beforeunload', e);
    });

    document.addEventListener('DOMContentLoaded', () => {
      const hash = location.hash.slice(1);
      scrollToId(hash);

      document.addEventListener('click', e => {
         
        const target = e.target;
        if (!target) {
          return;
        }

        const a = target.closest('a');
        if (!a) {
          return;
        }

        
        const clickedUrl = new URL(a.href);
        const clickedUrlHash = clickedUrl.hash;
        const currentUrl = new URL(location.href);
        clickedUrl.hash = '';
        currentUrl.hash = '';

        if (clickedUrl.toString() === currentUrl.toString()) {
          document.addEventListener('scroll', () => {
            scrollToId(clickedUrlHash.slice(1));
          }, { once: true });
        }
      });

      
      const tableOfContents = document.getElementById('TableOfContents');

      if (tableOfContents) {
        const links = Array.from(tableOfContents.querySelectorAll('a[href]'));

        links.forEach(link => {
          const linkTargetId = link.getAttribute('href').split('#')[1];
          if (!linkTargetId) {
            return;
          }

          const target = document.getElementById(linkTargetId);
          if (!target) {
            return;
          }

          const anchor = document.createElement('a');
          anchor.href = '#' + linkTargetId;
          anchor.className = 'headingAnchor';
          target.insertAdjacentElement('afterbegin', anchor);
        });
      }
    });
  })();
</script>
</head>
<body class="bg:fade-16@dark font:fade-86@dark">
    <nav id="mainNav" class="w:full fixed@sm bg:fade-16/.95@dark bg:white z:1000">
    <div class="
        h:full
        w:full
        max-w:1200
        mx:auto
        px:32
        d:flex
        flex-direction:column
        flex-direction:row@sm
        align-items:center
    ">
        <a href="/" class="block mr:3 p:8 filter:brightness(1.5):hover ~filter|0.1s">
            <img class="w:40" src="/img/geeklaunch.png" title="GeekLaunch" alt="GeekLaunch logo">
        </a>

        <div class="
            ml:auto@sm
            w:full
            d:flex
            flex-wrap:wrap
            justify-content:space-between
            justify-content:flex-end@sm
        ">
            
            
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                transition:150ms;ease-in
                
            " href="/about/" title="">About</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                transition:150ms;ease-in
                
            " href="/blog/" title="">Posts</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                transition:150ms;ease-in
                
            " href="https://www.youtube.com/c/GeekLaunch?sub_confirmation=1" title="">YouTube</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                transition:150ms;ease-in
                
            " href="https://weareindy.com/app/shared/forms/634577ccb25f8365f4aa7f42/zw1Icw3aBtCI90eLSzQVkpZiigUEBLHeaNKmJobnx4kTaPYMixQM3gDZMCFDsSHC/" title="">Contact</a>
            
        </div>
    </div>
</nav>
<div class="d:flex flex:column@<=sm pt:90@sm px:24 jc:center gap:44 word-break:break-word">
        <div class="max-w:700 w:full box:content-box">
<article class="box:border-box pt:32">
    <header class="mb:32">
        <a class="font:40 font:extrabold" href="https://geeklaunch.net/blog/how-to-speed-up-your-code-using-graphs/">How to speed up your code 224,444,739% using graphs</a>
        <div class="mt:16 f:fade-60">
            <time>Aug 6, 2022</time>
            </div>
    </header>

    
    <aside>
        <details class="
            ml:12_ul
            bl:2
            bl:fade-86
            bl:fade-40@dark
            mb:24
            py:4
            pl:12
            lh:1.5
            {content:'‣';pr:.3em;color:fade-70}_li::before
            {color:fade-50}_li::before@dark
            {text-underline-offset:3;font:medium;text-decoration:underline;text-decoration-color:fade-86;color:fade-40}_a
            {text-decoration-color:fade-30;color:fade-80}_a@dark
            {text-decoration-color:fade-60;color:fade-10}_a:hover
            {text-decoration-color:fade-60;color:fade-90}_a:hover@dark
        ">
            <summary class="
                cursor:pointer
                font-weight:semibold
                color:fade-40
                color:fade-80@dark
                color:fade-70::marker
                color:fade-50::marker@dark
            ">Contents</summary>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#anagram-de-duplicating">Anagram de-duplicating</a></li>
    <li><a href="#bit-packing">Bit packing</a></li>
    <li><a href="#graphs">Graphs</a></li>
    <li><a href="#short-circuits">Short circuits</a></li>
    <li><a href="#compiler-options">Compiler Options</a></li>
    <li><a href="#final-product">Final Product</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
        </details>
    </aside>
    <div class="
    {text-decoration-color:fade-60}_:where(a):hover
    {text-decoration:underline;text-decoration-color:fade-86;color:fade-40}_:where(a)
    {text-decoration-color:fade-30;color:fade-90}_:where(a)@dark
    {bl:5|solid;f:fade-34/.1}_:where(blockquote)
    {f:fade-76/.1}_:where(blockquote)@dark
    {font:90%;v:middle}_:where(code)
    {p:2;6;r:4}_:where(code:not(.highlight_*,pre_*))
    {text-decoration:1;line-through;fade-68}_:where(del)
    {text-decoration-color:red-64}_:where(del)@dark
    {text:14;p:10;20;0;width:fit;mx:auto;font:fade-56}_:where(figcaption)
    {font:fade-57}_:where(figcaption)@dark
    {font:40;font:extrabold}_:where(h1)
    {mt:.5em}_:where(h1,h2,h3)+:where(h1,h2,h3)
    {mt:2em}_:where(h1,h2,h3,h4,h5,h6)
    {mb:1em;font:32}_:where(h2)
    {font:24}_:where(h3)
    {font:20}_:where(h4)
    {font:16}_:where(h5)
    {font:14}_:where(h6)
    {font:fade-44}_:where(li)::marker
    {font:fade-68}_:where(li)::marker@dark
    {pl:.375em}_:where(li)
    {text-decoration:underline;#fce016;bg:transparent;text-decoration-color:rgb(252;224;22/.5)@dark}_:where(mark)
    {font:fade-36;font:16;line-height:1.65}_:where(p,li,details)
    {font:fade-80}_:where(p,li,details)@dark
    {my:1.125em}_:where(p,pre,blockquote,figure,ul,ol,table)
    {mt:0!}>:first-child
    {p:20;r:8;overflow:auto;bg:rgba(11,18,23,0.9)!;font:fade-90;lh:1.5}_:where(pre)
    {width:full;border-spacing:0}_:where(table)
    {v:baseline}_:where(td)
    {pl:0}_:where(td,th):first-child
    {pr:0}_:where(td,th):last-child
    {bb:1;solid;fade-92/.06;p:6;b:fade-4/.04@dark}_:where(td,th)
    {font:fade-78;font:14;text:left;font:fade-12@dark}_:where(th)
    {font:semibold}_:where(th,p_code,li_code,a,mark)
    {list-style-type:disc}_:where(ul)
    {pl:1.5em}_:where(ul,ol,blockquote)
    {max-width:full}_:where(video,img)
    {text-underline-offset:3}_:where(a,mark)
    {height:0.1rem;bg:fade-80;mx:40%;my:1.5rem}_:where(hr)
    {bg:fade-40}_:where(hr)@dark
    {cursor:pointer}_:where(details>summary)
    {text-decoration:none;pr:16;font:medium}_.headingAnchor
    {opacity:0;position:absolute;translateX(-100%)}_.headingAnchor@sm
    {content:'#'}_.headingAnchor::before
    {opacity:1}_:hover>.headingAnchor
    {color:fade-50}_.headingAnchor@dark
    {color:fade-70}_.headingAnchor:hover@dark
"><p>(This article got a shout-out in <a href="https://youtu.be/c33AZBnRHks?t=1068">Matt Parker&rsquo;s follow-up video</a>. Did you know <a href="https://youtube.com/c/GeekLaunch">I also make YouTube videos</a>?)</p>
<p><a href="https://twitter.com/standupmaths">Matt Parker</a> of <a href="https://www.youtube.com/standupmaths">Stand Up Maths</a> recently uploaded a video entitled &ldquo;Can you find: five five-letter words with twenty-five unique letters?,&rdquo; which I highly recommend you watch to understand the point of this post, the problem we&rsquo;re trying to solve, and the algorithm we&rsquo;ll be optimizing.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/_-AfhLQfb6w" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>In the video, he mentions that <a href="https://github.com/standupmaths/fiveletterworda">the Python code</a> he wrote to solve the &ldquo;five five-letter words with twenty-five unique letters&rdquo; problem (or the &ldquo;5-5-25&rdquo; problem, for short) took 2,760,670.3 seconds (31.95 days) to run.</p>
<p>Let&rsquo;s improve on this. <a href="https://github.com/encody/jotto-problem">My solution</a>…</p>
<ul>
<li>uses <a href="https://www.rust-lang.org/">Rust</a>,</li>
<li>is about four times longer than Parker&rsquo;s,</li>
<li>uses &ldquo;recursion&rdquo; and &ldquo;graphs&rdquo; <em>(ooh, fancy words)</em> and some other fun optimizations that will probably remind you of your CS classes.</li>
</ul>
<h2 id="anagram-de-duplicating">Anagram de-duplicating</h2>
<p>Parker mentioned this in his video. What we actually care about in this problem is finding the largest set of mutually-disjoint sets of letters that can be arranged into an English word. (The algorithm for finding such sets is similar to the <a href="https://en.wikipedia.org/wiki/Maximum_disjoint_set">maximum disjoint set problem</a>, and thus, so is the algorithm for solving the 5-5-25 problem.)</p>
<p>So, for the purposes of this problem, &ldquo;beard&rdquo; = &ldquo;bread&rdquo; = &ldquo;bared&rdquo;.</p>
<p>For the remainder of this post, &ldquo;word&rdquo; shall refer to one of these unordered sets of letters.</p>
<h2 id="bit-packing">Bit packing</h2>
<p>We could store a word as a hash set, array, or vector of characters, or a string construct, but there is an even more efficient medium: unsigned, 32-bit integers. Or rather, a <em>single</em>, unsigned, 32-bit integer.</p>
<p>Let&rsquo;s think of our integer as a list of 32 on-off switches. We can assign each letter of the alphabet to a switch (a = 0, b = 1, …), and encode a word by switching on the bits corresponding to the letters in the word. We&rsquo;ll have 6 bits left over, since the alphabet only contains 26 letters.</p>
<pre><code>&quot;bread&quot; = 0b100000000000011011 = 131099
         ...rqponmlkjihgfedcba

&quot;chunk&quot; = 0b100000010010010000100 = 1057924
         ...utsrqponmlkjihgfedcba
</code></pre>
<p>Bitwise operations will come in handy now!</p>
<p>If we want to figure out if two words have any letters in common, we simply bitwise-AND them together and see if any bits are set in the output. We can create a bitmask of multiple words by bitwise-ORing them together. This functionality is implemented for <a href="https://github.com/encody/jotto-problem/blob/master/src/main.rs#L153-L215">the Word struct in the solution</a>.</p>
<p>Not only are bitwise operations useful, they&rsquo;re also <em>really freaking fast</em>. They&rsquo;re what CPUs were built for.</p>
<p>To calculate a solution, we&rsquo;ll progressively create a bitmask of the words in the solution so far.</p>
<pre><code>&quot;bread&quot; | &quot;chunk&quot; = 0b100100010010010011111 = 1189023
                   ...utsrqponmlkjihgfedcba
</code></pre>
<p>Then we&rsquo;ll check new words against the bitmask to see if they&rsquo;re allowed to join the partial solution.</p>
<pre><code>(&quot;bread&quot; | &quot;chunk&quot;) &amp; &quot;witch&quot; == 0 ? ❌
(&quot;bread&quot; | &quot;chunk&quot;) &amp; &quot;imply&quot; == 0 ? ✅
</code></pre>
<h2 id="graphs">Graphs</h2>
<p>How do we decide which words to try to add to our solution? If we try <em>every single word</em>, we end up with a brute-force solution that takes a long time (<a href="https://en.wikipedia.org/wiki/Big_O_notation#Use_in_computer_science">Θ(n⁵)</a>) to complete. Let&rsquo;s try to be a little more clever about which words we try to add to our solution.</p>
<p>To do this, we&rsquo;ll create a <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)">graph</a>. Specifically, we&rsquo;ll be creating a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>. Each node in the graph will be a word. Edges will point from a word (A) to a later word (B) when the words (A) and (B) are disjoint. Our words have a well-defined ordering (since they are just numbers), so a &ldquo;later word&rdquo; is a word whose 32-bit integer encoding represents a higher number.</p>
<pre><code>Node            Encoding        Edges

&quot;bread&quot;         131099          [&quot;chunk&quot;, &quot;imply&quot;]
&quot;anger&quot;         139345          [&quot;witch&quot;, &quot;imply&quot;]
&quot;chunk&quot;         1057924         [&quot;imply&quot;]
&quot;witch&quot;         4718980         []
&quot;imply&quot;         16816384        []
</code></pre>
<p>We only need to have edges pointing to later disjoint words (and not to <em>all</em> disjoint words) because the order of the words in the solution doesn&rsquo;t matter. If a solution contains word (A) and word (B), our algorithm will discover the solution regardless of which word it encounters first. Having only the single edge from (A) to (B) and not also vice-versa means that the algorithm can still discover the solution containing both (A) and (B) when it encounters (A), but when it traverses (B), it excludes (A) from future (duplicate) traversals.</p>
<p>Our algorithm will traverse the graph and build a solution by recursively visiting the edges of a node in the current solution candidate and returning the longest disjoint sub-solution.</p>
<p>In a vacuum, this algorithm would still be O(n<sup>5</sup>), but due to the nature of the data and the way we&rsquo;re constructing the graph (it&rsquo;s pretty sparse—using the test data, there is no path in the graph that contains more than 15 nodes), traversals should be O(n<sup>2</sup>) in practice.</p>
<h2 id="short-circuits">Short circuits</h2>
<p>The algorithm is complete and correct at this point, but we can still speed it up with some shortcuts.</p>
<p>Let&rsquo;s add <a href="https://github.com/encody/jotto-problem/blob/master/src/main.rs#L122">a field to each node in our graph</a> that tells us the length of the longest possible path after this node. If our search needs 3 more words and it encounters a node that says its longest path only contains 1 more node, our search can skip that node early.</p>
<p>We can also maintain <a href="https://github.com/encody/jotto-problem/blob/master/src/main.rs#L20-L34">a set of word combinations</a> that we have already tried and failed to use in a solution.</p>
<h2 id="compiler-options">Compiler Options</h2>
<p>Since we only care about the runtime of this program, we can have the compiler optimize the heck out of it:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[profile.release]
</span></span><span style="display:flex;"><span>lto = <span style="color:#ff6ac1">true</span>
</span></span><span style="display:flex;"><span>codegen-units = <span style="color:#ff9f43">1</span>
</span></span><span style="display:flex;"><span>panic = <span style="color:#5af78e">&#34;abort&#34;</span>
</span></span></code></pre></div><h2 id="final-product">Final Product</h2>
<pre><code>$ time ./target/release/jotto-problem

[solutions output]

Found 537 solutions that are 5 words long

________________________________________________________
Executed in    1.23 secs    fish           external
   usr time    1.28 secs    0.14 millis    1.28 secs
   sys time    0.04 secs    1.05 millis    0.04 secs
</code></pre>
<p>Not bad for a laptop!</p>
<p>Try it for yourself:</p>
<ul>
<li>Install <a href="https://www.rust-lang.org/tools/install">Rust</a>.</li>
<li>Download the <a href="https://github.com/dwyl/english-words">English word list</a>.</li>
<li>Download the <a href="https://github.com/encody/jotto-problem">source code</a>.</li>
<li>Update <a href="https://github.com/encody/jotto-problem/blob/master/src/main.rs#L4">the <code>PATH</code> variable in main.rs</a> to the location where you saved the word list.</li>
<li>Run <code>./build-and-run.sh</code> in your terminal.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=_-AfhLQfb6w">Can you find: five five-letter words with twenty-five unique letters?</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">Modeling graphs in Rust using vector indices</a></li>
<li><a href="https://aloso.github.io/2021/03/09/creating-an-iterator">Creating an Iterator in Rust</a></li>
<li><a href="https://gitlab.com/bpaassen/five_clique/-/tree/main/">Five Clique</a></li>
</ul>
<hr>
<p>I&rsquo;m a software engineer for <a href="https://near.org/">NEAR Protocol</a>, head of education at the <a
    href="https://www.blockchainacceleration.org/">Blockchain Acceleration Foundation</a>, and a graduate
  student at the <a href="https://www.titech.ac.jp/">Tokyo Institute of Technology</a>.</p>
<p>Connect with me <a href="https://twitter.com/sudo_build">on Twitter</a>.</p>
</div>
</article>
<footer class="py:24">
    <div class="f:fade-50 f:fade-60@dark f:14 mb:8">© Copyright 2022 Jacob Lindahl</div>
    <div class="f:fade-80 f:fade-40@dark f:12">Theme <a class="f:bold" href="https://github.com/serkodev/holy"
            _target="_blank">Holy</a></div>
</footer>
</div>
    </div>
</body>

</html>
