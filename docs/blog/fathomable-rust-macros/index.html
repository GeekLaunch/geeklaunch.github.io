<!DOCTYPE html>
<html><head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <title>Fathomable Rust Macros - GeekLaunch</title>

    
    

    <meta name="description" content="Rust macros are compile-time constructs that operate on streams of Rust language tokens.
A brief aside on compilation What are &ldquo;Rust language tokens&rdquo;?
When a compiler begins compiling a program, it first reads in the source code file. For simplicity&rsquo;s sake, let&rsquo;s say the compiler stores that source code in a string. The next step is to step through the string, character by character, and divide it up into &ldquo;tokens.&rdquo;" />
    <meta name="author" content="map[name:Jacob Lindahl twitter:sudo_build]" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Fathomable Rust Macros" />
    <meta property="og:description" content="A breakdown of the inner workings and authorship of macros in Rust" />
    <meta property="og:url" content="https://geeklaunch.io/blog/fathomable-rust-macros/" />
    <meta property="og:image" content="https://geeklaunch.io/img/geeklaunch.png" />
    <meta property="og:site_name" content="GeekLaunch" />

    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:site" content="Geek_Launch" />
    
    
    <meta name="twitter:creator" content="sudo_build" />
    

    

    <link id="highlight-theme-light" rel="stylesheet"
        href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/github.min.css">
    <link id="highlight-theme-dark" disabled rel="stylesheet"
        href="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/github-dark.min.css">
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.6.0/highlight.min.js"></script>
    <script src="https://unpkg.com/highlightjs-solidity@2.0.5/dist/solidity.min.js"></script>

    <link href="https://unpkg.com/@master/normal.css@1" rel="stylesheet">
    <script src="https://unpkg.com/@master/css@1"></script>
    <script src="https://unpkg.com/themes.js@0.0.10"></script>
    <script>
        (() => {
            hljs.highlightAll();

            const themes = new window.Themes();
            window.themes = themes;

            const updateSyntaxTheme = () => {
                const darkStylesheet = document.getElementById('highlight-theme-dark');
                const lightStylesheet = document.getElementById('highlight-theme-light');
                if (themes.documentTheme === 'dark') {
                    lightStylesheet.disabled = true;
                    darkStylesheet.disabled = false;
                } else {
                    lightStylesheet.disabled = false;
                    darkStylesheet.disabled = true;
                }
            };

            updateSyntaxTheme();

            themes.onChange = (theme) => {
                updateSyntaxTheme();
            };
        })();
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DMBPKLBF8X"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-DMBPKLBF8X', { 'anonymize_ip': false });
}
</script>

<style>
  html {
    scroll-behavior: smooth;
    scroll-padding-top: 2em;
  }

  @media (min-width: 768px) {
    html {
      scroll-padding-top: 64px;
    }
  }

  .table {
    display: initial;
  }

  @keyframes highlight {
    0% {
      background-color: rgba(226, 230, 30, 0.4);
      outline: 0.2rem solid rgba(226, 230, 30, 0.4);
    }

    100% {
      background-color: unset;
      outline: 0.2rem solid transparent;
    }
  }

  :target {
    animation: highlight 1.2s forwards;
  }

</style>
<script>
  (() => {
    document.addEventListener('DOMContentLoaded', () => {

      
      const tableOfContents = document.getElementById('TableOfContents');

      if (tableOfContents) {
        const links = Array.from(tableOfContents.querySelectorAll('a[href]'));

        links.forEach(link => {
          const linkTargetId = link.getAttribute('href').split('#')[1];
          if (!linkTargetId) {
            return;
          }

          const target = document.getElementById(linkTargetId);
          if (!target) {
            return;
          }

          const anchor = document.createElement('a');
          anchor.href = '#' + linkTargetId;
          anchor.className = 'headingAnchor';
          anchor.innerText = '#';
          target.insertAdjacentElement('afterbegin', anchor);
        });
      }
    });
  })();
</script>
</head>
<body class="bg:fade-16@dark font:fade-86@dark">
    <nav id="mainNav" class="
    w:full
    fixed@sm
    bg:white/.9
    bg:fade-16/.9@dark
    z:1000
    backdrop-filter:blur(3px)
">
    <div class="
        h:full
        w:full
        max-w:1200
        mx:auto
        px:32
        d:flex
        flex-direction:column
        flex-direction:row@sm
        align-items:center
    ">
        <a href="/" class="block mr:3 p:8 filter:brightness(1.5):hover ~filter|0.1s">
            <img class="w:40" src="/img/geeklaunch.png" title="GeekLaunch" alt="GeekLaunch logo">
        </a>

        <div class="
            ml:auto@sm
            w:full
            d:flex
            flex-wrap:wrap
            justify-content:space-between
            justify-content:flex-end@sm
        ">
            
            
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                
            " href="/about/" title="">About</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                
            " href="/blog/" title="">Posts</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                
            " href="https://www.youtube.com/c/GeekLaunch?sub_confirmation=1" title="">YouTube</a>
            
            
            <a class="
                font:semibold
                font:fade
                font:fade-10:hover
                font:fade-30.active
                font:fade-80@dark
                font:fade-96:hover@dark
                font:fade-90.active@dark
                p:12
                p:18@sm
                
            " href="https://weareindy.com/app/shared/forms/634577ccb25f8365f4aa7f42/zw1Icw3aBtCI90eLSzQVkpZiigUEBLHeaNKmJobnx4kTaPYMixQM3gDZMCFDsSHC/" title="">Contact</a>
            
        </div>
    </div>
</nav>
<div class="d:flex flex:column@<=sm pt:90@sm px:24 jc:center gap:44 word-break:break-word">
        <div class="max-w:700 w:full box:content-box">
<article class="box:border-box pt:32">
    <header class="mb:32">
        <h1 class="font:40 font:extrabold">Fathomable Rust Macros</h1>
        
        <p class="font:18 mt:12 lh:1.4 font:semibold color:fade-30 color:fade-70@dark">A breakdown of the inner workings and authorship of macros in Rust</p>
        
        <div class="mt:16 f:fade-60 text-decoration:underline_:where(a):hover">
            <p><a href="https://twitter.com/sudo_build" rel="author">Jacob Lindahl</a><span class="mx:10">&mdash;</span><a href="https://geeklaunch.io/blog/fathomable-rust-macros/"><time pubdate datetime="2022-10-25 00:00:00 &#43;0000 UTC" title="October 25, 2022">Oct 25, 2022</time></a></p>
        </div>
    </header>

    
    <aside>
        <details class="
            ml:12_ul
            bl:2
            bl:fade-86
            bl:fade-40@dark
            mb:24
            py:4
            pl:12
            lh:1.5
            {content:'#';pr:.3em;color:fade-70}_li::before
            {color:fade-50}_li::before@dark
            {text-underline-offset:3;font:medium;text-decoration:underline;text-decoration-color:fade-86;color:fade-40}_a
            {text-decoration-color:fade-30;color:fade-80}_a@dark
            {text-decoration-color:fade-60;color:fade-10}_a:hover
            {text-decoration-color:fade-60;color:fade-90}_a:hover@dark
        ">
            <summary class="
                cursor:pointer
                font-weight:semibold
                color:fade-40
                color:fade-80@dark
                color:fade-70::marker
                color:fade-50::marker@dark
            ">Contents</summary>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#a-brief-aside-on-compilation">A brief aside on compilation</a></li>
    <li><a href="#declarative-macros">Declarative macros</a>
      <ul>
        <li><a href="#nested-macros-and-recursion">Nested macros and recursion</a></li>
      </ul>
    </li>
    <li><a href="#procedural-macros">Procedural macros</a></li>
    <li><a href="#authoring-procedural-macros">Authoring procedural macros</a></li>
    <li><a href="#communicating-with-the-compiler">Communicating with the compiler</a></li>
    <li><a href="#parameterization-and-configuration">Parameterization and configuration</a></li>
    <li><a href="#practical-example">Practical Example</a></li>
    <li><a href="#further-reading">Further Reading</a></li>
  </ul>
</nav>
        </details>
    </aside>
    <div class="
    {text-decoration-color:fade-60}_:where(a):hover
    {text-decoration:underline;text-decoration-color:fade-86;color:fade-40}_:where(a)
    {text-decoration-color:fade-30;color:fade-90}_:where(a)@dark
    {bl:4|solid;b:fade-84;color:fade-34}_:where(blockquote)
    {b:fade-38;color:fade-86}_:where(blockquote)@dark
    {font:90%;v:middle}_:where(code)
    {text-decoration:1;line-through;fade-68}_:where(del)
    {text-decoration-color:red-64}_:where(del)@dark
    {text:14;p:10;20;0;width:fit;mx:auto;font:fade-56}_:where(figcaption)
    {font:fade-57}_:where(figcaption)@dark
    {font:40;font:extrabold}_:where(h1)
    {mt:.5em}_:where(h1,h2,h3)+:where(h1,h2,h3)
    {mt:2em}_:where(h1,h2,h3,h4,h5,h6)
    {mb:1em;font:32}_:where(h2)
    {font:24}_:where(h3)
    {font:20}_:where(h4)
    {font:16}_:where(h5)
    {font:14}_:where(h6)
    {font:fade-44}_:where(li)::marker
    {font:fade-68}_:where(li)::marker@dark
    {pl:.375em}_:where(li)
    {text-decoration:underline;#fce016;bg:transparent;text-decoration-color:rgb(252;224;22/.5)@dark}_:where(mark)
    {font:fade-36;font:16;line-height:1.65}_:where(p,li,details)
    {font:fade-80}_:where(p,li,details)@dark
    {my:0.125em}_:where(li>ul)
    {my:1.125em}_:where(p,pre,blockquote,figure,ul,ol,table)
    {mt:0!}>:first-child
    {width:full;border-spacing:0}_:where(table)
    {v:baseline}_:where(td)
    {pl:0}_:where(td,th):first-child
    {pr:0}_:where(td,th):last-child
    {bb:1;solid;fade-92/.06;p:6;b:fade-4/.04@dark}_:where(td,th)
    {font:fade-78;font:14;text:left;font:fade-12@dark}_:where(th)
    {font:semibold}_:where(th,a,mark,:not(pre)>code)
    {list-style-type:disc}_:where(ul)
    {pl:1.5em}_:where(ul,ol,blockquote)
    {max-width:full}_:where(video,img)
    {text-underline-offset:3}_:where(a,mark)
    {height:0.1rem;bg:fade-80;mx:40%;my:1.5rem}_:where(hr)
    {bg:fade-40}_:where(hr)@dark
    {cursor:pointer}_:where(details>summary)
    {text-decoration:none;pr:16;font:medium;color:fade-80}_.headingAnchor
    {color:fade-60}_.headingAnchor:hover
    {opacity:0;position:absolute;translateX(-100%)}_.headingAnchor@sm
    {opacity:1}_:hover>.headingAnchor
    {opacity:1}_:target>.headingAnchor
    {color:fade-50}_.headingAnchor@dark
    {color:fade-70}_.headingAnchor:hover@dark
    {border-radius:2;lh:1.5}_:where(pre>code)
"><p>Rust macros are compile-time constructs that operate on streams of Rust language tokens.</p>
<h2 id="a-brief-aside-on-compilation">A brief aside on compilation</h2>
<p>What are &ldquo;Rust language tokens&rdquo;?</p>
<p>When a compiler begins compiling a program, it first reads in the source code file. For simplicity&rsquo;s sake, let&rsquo;s say the compiler stores that source code in a string. The next step is to step through the string, character by character, and divide it up into &ldquo;tokens.&rdquo;</p>
<p>For example, a Rust snippet like:</p>
<pre><code class="language-rust">let foo: u32 = 30;
</code></pre>
<p>Might be &ldquo;tokenized&rdquo; into:</p>
<pre><code class="language-rust">[
    KeywordLet,
    Identifier(&quot;foo&quot;),
    Colon,
    Identifier(&quot;u32&quot;),
    SingleEquals,
    NumericLiteral(&quot;30&quot;),
    Semicolon,
]
</code></pre>
<p>(Note that this is a completely imaginary example.)</p>
<p>A macro takes a stream of tokens akin to the above as input, and also outputs a stream of tokens.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> This has some major implications:</p>
<ul>
<li>Rust macros can add new code: add a trait implementation, create a new struct, write a new function, etc.</li>
<li>Rust macros cannot interact with the logic in the code (e.g. see whether a type implements a trait, call a function declared in the source, etc.), because the logic has not actually been constructed yet.</li>
</ul>
<hr>
<p>There are two main categories of Rust macros: declarative macros and procedural macros.</p>
<h2 id="declarative-macros">Declarative macros</h2>
<p>Declarative macros can be declared and used alongside other code. They are declared using the special <code>macro_rules!</code> construct, and have some unique syntax:</p>
<pre><code class="language-rust">macro_rules! my_macro {
    ($a: ident =&gt; $b: expr) =&gt; {
        fn $a() {
            println!(&quot;{}&quot;, $b);
        }
    };
    ($a: ident, $b: expr) =&gt; {
        println!(&quot;{} {}&quot;, $a, $b);
    };
}
</code></pre>
<p>Declarative macros accept Rust tokens as input and perform pattern matching against them. In the example above, the macro <code>my_macro</code> matches two different patterns:</p>
<ol>
<li>An identifier and an expression separated by a fat arrow <code>=&gt;</code>, and</li>
<li>An identifier and an expression separated by a comma <code>,</code>.</li>
</ol>
<p>This macro could be invoked like:</p>
<pre><code class="language-rust">my_macro!(foo, 45);
my_macro!(bar =&gt; &quot;hello&quot;);
my_macro!(baz =&gt; 9 * 8);
</code></pre>
<h3 id="nested-macros-and-recursion">Nested macros and recursion</h3>
<p>One of the most popular Rust crates, <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a>, includes a declarative macro <a href="https://docs.rs/serde_json/latest/serde_json/macro.json.html"><code>json!()</code></a>, which allows you to write JSON-like syntax in your Rust code. It returns a <a href="https://docs.rs/serde_json/latest/serde_json/enum.Value.html"><code>serde_json::Value</code></a>.</p>
<pre><code class="language-rust">json!({
    &quot;id&quot;: 42,
    &quot;name&quot;: {
        &quot;first&quot;: &quot;John&quot;,
        &quot;last&quot;: &quot;Zoidberg&quot;,
    },
});
</code></pre>
<p>As it turns out, you can put any valid Rust expression (that evaluates to a value that implements <code>Serialize</code>) as the value:</p>
<pre><code class="language-rust">json!({
    &quot;id&quot;: 21 + 21, // Computed expression
    &quot;name&quot;: {
        &quot;first&quot;: &quot;John&quot;,
        &quot;last&quot;: &quot;Zoidberg&quot;,
    },
});
</code></pre>
<p>And I mean <em>any</em> valid Rust expression…</p>
<pre><code class="language-rust">json!({
    &quot;id&quot;: 21 + 21,
    &quot;name&quot;: json!({ // This is another macro invocation!
        &quot;first&quot;: &quot;John&quot;,
        &quot;last&quot;: &quot;Zoidberg&quot;,
    }),
});
</code></pre>
<p>This ability extends to the code that your macro generates as well. For example, we can write a basic parser that recursively translates the logic symbols for AND (∧; <code>^</code> in code) and OR (∨; <code>v</code> in code) into the Rust equivalents.</p>
<pre><code class="language-rust">macro_rules! andor {
    ($a: ident ^ $b: ident $($tail: tt)*) =&gt; {
        $a &amp;&amp; andor!($b $($tail)*) // Recursive invocation
    };
    ($a: ident v $b: ident $($tail: tt)*) =&gt; {
        $a || andor!($b $($tail)*) // Recursive invocation
    };
    ($($a: tt)*) =&gt; {
        $($a)*
    }
}

andor!(true ^ false v false ^ true) // true &amp;&amp; false || false &amp;&amp; true
// =&gt; false
</code></pre>
<p>Because it is a potentially infinite operation, the macro recursion has a <a href="https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute">maximum depth defined by the Rust compiler</a>.</p>
<h2 id="procedural-macros">Procedural macros</h2>
<p>Procedural macros are written using normal Rust code (not a unique syntax), which is compiled, and then run by the compiler when invoked. For this reason, procedural macros are also sometimes called &ldquo;compiler plugins.&rdquo;</p>
<p>Because crates = compilation units, in order for a procedural macro to be compiled before its execution, procedural macros must be defined in (and subsequently exported from) a different crate from that in which they are used. These must be library crates with the following in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
<p>Procedural macros appear in three forms, which are all invoked differently:</p>
<ul>
<li>
<p>Attribute-like. <br>
Input: annotated item. <br>
Ouput <em>replaces</em> input. (Original input does not exist in final token stream.)</p>
<pre><code class="language-rust">#[my_attribute_macro]
struct MyStruct; // This struct is the input to the macro

struct AnotherStruct; // This struct is not part of the macro's input
</code></pre>
</li>
<li>
<p>Custom derive. <br>
Input: annotated item. <br>
Output <em>is appended to</em> input. (Original input still exists in final token stream.)</p>
<pre><code class="language-rust">#[derive(MyDeriveMacro)]
struct MyStruct; // This struct is the input to the macro

struct AnotherStruct; // This struct is not part of the macro's input
</code></pre>
</li>
<li>
<p>Function-like. <br>
Input: enclosed token stream. Delimiters are <code>[]</code>, <code>{}</code>, or <code>()</code>. <br>
Output <em>replaces</em> input. (Original input does not exist in final token stream.)</p>
<pre><code class="language-rust">my_function_like_macro!(arbitrary + token : stream 00);
// is the same as
my_function_like_macro![arbitrary + token : stream 00];
// is the same as
my_function_like_macro!{arbitrary + token : stream 00};
</code></pre>
</li>
</ul>
<p>In this post, I will discuss writing attribute and derive macros.</p>
<h2 id="authoring-procedural-macros">Authoring procedural macros</h2>
<p>At first glance, writing a procedural macro from scratch can be <em>really daunting</em>:</p>
<pre><code class="language-rust">use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn my_attribute_macro(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    todo!(&quot;Good luck!&quot;)
}
</code></pre>
<p>This macro could be invoked like this:</p>
<pre><code class="language-rust">#[my_attribute_macro]
struct AnnotatedItem;
</code></pre>
<p>In this case, the <code>attr</code> token stream would be empty, and the <code>item</code> token stream would contain the <code>AnnotatedItem</code> struct.</p>
<p>If you invoke the macro like this:</p>
<pre><code class="language-rust">#[my_attribute_macro(attribute_tokens)]
fn my_function() {}
</code></pre>
<p>In this case, the <code>attr</code> token stream would contain <code>attribute_tokens</code>, and the <code>item</code> token stream would contain the <code>my_function</code> function.</p>
<p>Cool. We have the basic infrastructure set up, now we just have parse the input token streams.</p>
<p>The Rust compiler hasn&rsquo;t even been so kind as to create the syntax tree for us yet. We just get a token stream, and we have to somehow parse it into something sensible (like a struct definition, <code>impl</code> block, etc.), manipulate it in some way, and then synthesize an output that the compiler can make sense of as valid code.</p>
<p>That&rsquo;s a <em>lot</em> of work to do!</p>
<p>Enter: <code>syn</code> and <code>quote</code>.</p>
<h2 id="communicating-with-the-compiler">Communicating with the compiler</h2>
<p><a href="https://crates.io/crates/syn"><code>syn</code></a> and <a href="https://crates.io/crates/quote"><code>quote</code></a> are a pair of crates that simplify token stream manipulation. <code>syn</code> provides utilities for parsing token streams into syntax trees, and <code>quote</code> for converting Rust-like code back into token streams.</p>
<p>The basic use-cases for each of these crates are extremely simple—they&rsquo;re very well-designed crates!</p>
<p>Here is a bare-bones attribute macro using <code>syn</code> and <code>quote</code>, which does absolutely nothing (it returns its input):</p>
<pre><code class="language-rust">use proc_macro::TokenStream;
use syn::{parse_macro_input, AttributeArgs, Item};
use quote::quote;

#[proc_macro_attribute]
pub fn my_attribute_macro(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    let _attr = parse_macro_input!(attr as AttributeArgs);
    let item = parse_macro_input!(item as Item);

    quote!{
        #item
    }.into()
}
</code></pre>
<p>The <code>parse_macro_input</code> macro tries to parse a <code>TokenStream</code> into a <code>syn</code> data structure, and produces a compiler error on failure. The <a href="https://docs.rs/syn"><code>syn</code> data structures and documentation</a> are worth perusing on your own. They will give you a pretty good idea of what a syntax tree might look like.</p>
<p>The <code>Item</code> parsed in the example above is an enum, which you can <code>match</code> against:</p>
<pre><code class="language-rust">match item { // The annotated item was parsed as...
    Item::Enum(e) =&gt; {}, // ...an enum
    Item::Fn(f) =&gt; {}, // ...a function
    Item::Impl(i) =&gt; {}, // ...an impl block
    Item::Struct(s) =&gt; {}, // ...a struct

    // ...and so on and so forth
    _ =&gt; todo!(),
}
</code></pre>
<p>The <code>quote</code> macro produces a <code>proc_macro2::TokenStream</code> (which can be easily transformed into a normal <code>proc_macro::TokenStream</code> via <code>Into::into</code>) from some input that is like Rust code. It also supports variable interpolation, via the <code>#identifier</code> syntax seen above.</p>
<p>In the world of macro authorship, <code>syn</code> and <code>quote</code> are pretty ubiquitous. <a href="https://github.com/dtolnay/thiserror/blob/464e2e798eea0985af3c2c16cc55866e2918f774/impl/src/expand.rs">Here&rsquo;s an example of <code>syn</code> and <code>quote</code> used in the popular crate <code>thiserror</code></a>.</p>
<h2 id="parameterization-and-configuration">Parameterization and configuration</h2>
<p>The last tool in our belt for building maintainable and usable macros is <a href="https://crates.io/crates/darling"><code>darling</code></a>. The crate&rsquo;s stated description is:</p>
<blockquote>
<p>A proc-macro library for reading attributes into structs when implementing custom derives.</p>
</blockquote>
<p>However, it is useful for both custom derives and attribute macros. <code>syn</code> and <code>quote</code> are useful for parsing and manipulating streams of normal Rust tokens, and <code>darling</code> is useful for parsing attribute and item input streams into custom structs, attaching custom logic to process, and reporting errors, making the combination of these three crates a powerful framework for procedural macro authorship.</p>
<h2 id="practical-example">Practical Example</h2>
<p>Here is an example of a very simple derive macro using all three crates, complete with <a href="https://docs.rs/darling/0.14.1/darling/error/struct.Accumulator.html">error-handling</a>, an optional configuration parameter, and some of <code>darling</code>&rsquo;s <a href="https://docs.rs/darling/0.14.1/darling/#fromderiveinput">auto-forwarded fields</a> (<code>data</code>, <code>generics</code>, <code>ident</code>, <code>fields</code>).</p>
<pre><code class="language-rust">use darling::{FromDeriveInput, FromVariant};
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Path};

#[derive(Debug, FromDeriveInput)]
// The struct will be deserialized from a `#[display]` attribute on any kind of enum
#[darling(attributes(display), supports(enum_any))]
struct EnumMeta {
    // Try to optionally deserialize an item path
    pub transform: Option&lt;Path&gt;,

    // Forwarded attributes
    pub ident: syn::Ident,
    pub generics: syn::Generics,
    pub data: darling::ast::Data&lt;VariantVisitor, ()&gt;,
}

#[derive(Debug, FromVariant)]
struct VariantVisitor {
    // The name of the enum variant
    pub ident: syn::Ident,
    pub fields: darling::ast::Fields&lt;()&gt;,
}

fn expand(meta: EnumMeta) -&gt; Result&lt;TokenStream2, darling::Error&gt; {
    let EnumMeta {
        transform,
        data,
        generics,
        ident,
    } = meta;

    let variants = data.take_enum().unwrap();

    let match_arms = variants.iter().map(|variant| {
        let i = &amp;variant.ident;
        let name = i.to_string();
        match variant.fields.style {
            darling::ast::Style::Tuple =&gt; {
                quote! { Self :: #i ( .. ) =&gt; #name , }
            }
            darling::ast::Style::Struct =&gt; {
                quote! { Self :: #i { .. } =&gt; #name , }
            }
            darling::ast::Style::Unit =&gt; {
                quote! { Self :: #i  =&gt; #name , }
            }
        }
    });

    // Properly includes generics in output
    let (imp, ty, wher) = generics.split_for_impl();

    // Rust code output
    Ok(quote! {
        impl #imp std::fmt::Display for #ident #ty #wher {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
                write!(f, &quot;{}&quot;, #transform (
                    match self { #(#match_arms)* }
                ))
            }
        }
    })
}

// Declares the name of the macro and the attributes it supports
#[proc_macro_derive(Display, attributes(display))]
pub fn derive_display(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    FromDeriveInput::from_derive_input(&amp;input)
        .and_then(expand)
        .map(Into::into)
        // Error handling
        .unwrap_or_else(|e| e.write_errors().into())
}
</code></pre>
<p><a href="https://github.com/GeekLaunch/hello-rust-macros">This code is also available on GitHub</a>.</p>
<p>This derive macro creates an implementation of <code>Display</code> on the targeted enum. It optionally accepts a <code>transform</code> attribute field, which is a path to a function which transforms the name of the variant before it is written out.</p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">The &ldquo;Macros&rdquo; chapter in The Rust Book</a></li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">dtolnay&rsquo;s procedural macros workshop</a></li>
<li><a href="https://carlkcarlk.github.io/rust-ast-explorer/">Rust AST Explorer</a> (credit: <a href="https://matklad.github.io/">matklad</a>)</li>
</ul>
<hr>
<p>I&rsquo;m a software engineer for <a href="https://near.org/">NEAR Protocol</a>, head of education at the <a
    href="https://www.blockchainacceleration.org/">Blockchain Acceleration Foundation</a>, and a graduate
  student at the <a href="https://www.titech.ac.jp/">Tokyo Institute of Technology</a>.</p>
<p>Connect with me <a href="https://twitter.com/sudo_build">on Twitter</a>.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Correction from <a href="https://matklad.github.io/">matklad</a>:</p>
<blockquote>
<p>The macro evaluation process is &hellip; messy, a correct thing to say is that &ldquo;in rust compiler, parsing, name resolution, and macro expansion are mutually recursive procedures which happen at the same time&rdquo;. Luckily, I think for the purposes of this post we don&rsquo;t need to explain when macro expansion happens, it is enough to say &ldquo;tokens is what is used as input or output of the macro. Macros don&rsquo;t have direct access to a parsed AST, but a macro can parse input tokens itself&rdquo;.</p>
</blockquote>
&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
</ol>
</div>
</div>
</article>
<footer class="py:24 f:fade-50 f:fade-60@dark f:14 d:flex flex:col gap:8"><p>
        This work is licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
    </p><p>© Copyright 2022 Jacob Lindahl</p>
</footer>
</div>
    </div>
</body>

</html>
